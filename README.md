### Замыкания.
- Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В JavaScript, все функции изначально являются замыканиями (есть только одно исключение, "new Function").

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства Environment, и все они могут получить доступ к внешним переменным.

Несколько слов о технических деталях: свойстве Environment и о том, как работает лексическое окружение.

### Промис.
- Раньше, для выполнения асинхронных действий использовались функции колбэки в сочетании с событиями onload и onerror. Но это было не удобно, т.к. при нескольких последующих асинхронных действиях следующий асинхронный запрос необходимо было включать в колбэк из-за чего образуется адская пирамида колбэков, код становится не читаемым.
- Промисы решили эту проблему.
 let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  resolve('result');
  reject(new Error('error text'));
});
Это специальный объект в JavaScript, аргументом передается функция исполнитель(executor) в теле которой выполняет асинхронное действие и по окончании выполнения  результат передается при помощи встроенных колбэков в случае успеха resolve('результат') либо reject('ошибка') в случае ошибки, обычно передается объект ошибки, но не обязательно. Далее результат передается обработчикам, которые записаны при помощи специального синтаксиса .then, обработчиков может быть сколь угодно много, читаемость кода при этом не ухудшается каждый обработчик, записанный при помощи then возвращает промис.
- В современной ращработке для более легкого чтения кода используется синтаксис async/await, что на самом деле является синтаксическим сахаром для более легкого написания промисов.

### Микро / макро таски, событийный цикл.
- Когда промис выполненяется, обработчик, записанный при помощи then или await попадают в очередь на исполнение эта очередь называется microtask queue или очередь микро задач. JavaScript выполнит всю очередь микрозадач, когда освободится от выполнения текущего кода.

- Задачи поступившие на исполнение, когда движок занят чем-то другим, попадают в очередь macrotask queue или очередь макрозадач, исполнение загруженного внешнего скрипта, задачи, которые были запланированы при помощи setTimeout, срабатывание слушателей событий браузера.

- Событийный цикл это бесконечный цикл, в котором JavaScript ожидает задачи, исполняет их и снова ждет появления новых задач.
- После каждой макрозадачи JavaScript выполняет все скопившиеся микрозадачи, далее происходит рендеринг, если необходимо отобразить изменения на странице далее выполняется следующая макрозадача и так далее в бесконечном цикле.

